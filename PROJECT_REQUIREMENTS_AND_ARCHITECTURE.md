# Capstone Project: Утилита для генерации тестовых данных
## Требования, архитектура и план реализации

---

## 1. ОПИСАНИЕ ПРОЕКТА

**Название утилиты:** DataForge (или можно выбрать другое)

**Назначение:** Консольная утилита для генерации тестовых JSON данных на основе пользовательской схемы данных. Используется для тестирования data pipeline, валидации трансформаций данных.

**Формат вывода:** JSON (JSON Lines - https://jsonlines.org/)

---

## 2. ФУНКЦИОНАЛЬНЫЕ ТРЕБОВАНИЯ (Functional Requirements)

### FR-1: Парсинг схемы данных
- **FR-1.1:** Утилита должна принимать схему данных в формате JSON
- **FR-1.2:** Схема может быть передана двумя способами:
  - Как строка в командной строке
  - Как путь к JSON файлу со схемой
- **FR-1.3:** Схема должна поддерживать следующие типы данных:
  - `timestamp` - текущий Unix timestamp
  - `str` - строковые значения
  - `int` - целочисленные значения
- **FR-1.4:** Для каждого типа поддерживаются следующие стратегии генерации:
  - `rand` - случайная генерация
  - `[value1, value2, ...]` - случайный выбор из списка
  - `rand(from, to)` - случайное число в диапазоне (только для int)
  - `конкретное_значение` - статическое значение
  - `пустое_значение` - пустое значение (None для int, "" для str)

### FR-2: Генерация данных
- **FR-2.1:** Генерация случайных UUID для типа `str:rand` с использованием `uuid.uuid4()`
- **FR-2.2:** Генерация случайных целых чисел для `int:rand` в диапазоне [0, 10000]
- **FR-2.3:** Генерация случайных значений из списка с использованием `random.choice()`
- **FR-2.4:** Генерация случайных чисел в заданном диапазоне для `int:rand(from, to)`
- **FR-2.5:** Генерация текущего Unix timestamp для типа `timestamp:`
- **FR-2.6:** Использование статических значений где указано
- **FR-2.7:** Каждая строка данных должна содержать все ключи из схемы

### FR-3: Работа с файлами
- **FR-3.1:** Генерация указанного количества JSON файлов
- **FR-3.2:** Каждый файл должен содержать указанное количество строк данных
- **FR-3.3:** Поддержка префиксов для имен файлов:
  - `count` - порядковый номер (file_name_1.json, file_name_2.json, ...)
  - `random` - случайное число
  - `uuid` - уникальный UUID
- **FR-3.4:** Сохранение файлов по указанному пути (относительному или абсолютному)
- **FR-3.5:** Формат вывода - JSON Lines (каждая строка - отдельный JSON объект)
- **FR-3.6:** Если `files_count=0`, вывод данных в консоль (stdout)

### FR-4: Управление файлами
- **FR-4.1:** Опция `clear_path` для удаления существующих файлов с совпадающим именем перед генерацией
- **FR-4.2:** Проверка существования и валидности пути для сохранения

### FR-5: Многопроцессорная обработка
- **FR-5.1:** Поддержка параллельной генерации файлов с использованием multiprocessing
- **FR-5.2:** Равномерное распределение количества файлов между процессами
- **FR-5.3:** Автоматическое ограничение количества процессов до `os.cpu_count()`

### FR-6: Конфигурация
- **FR-6.1:** Все параметры должны иметь значения по умолчанию
- **FR-6.2:** Значения по умолчанию хранятся в файле `default.ini`
- **FR-6.3:** Значения считываются с помощью `configparser`
- **FR-6.4:** Имена параметров в `default.ini` идентичны параметрам командной строки

### FR-7: Интерфейс командной строки
- **FR-7.1:** Использование `argparse` для парсинга аргументов
- **FR-7.2:** Все параметры можно передать через командную строку
- **FR-7.3:** Команда `--help` должна показывать:
  - Название утилиты
  - Описание каждого параметра
  - Значения по умолчанию
  - Примеры использования

### FR-8: Логирование
- **FR-8.1:** Все важные действия логируются в консоль
- **FR-8.2:** Использование модуля `logging`
- **FR-8.3:** Уровни логирования:
  - `INFO` - начало/завершение генерации, прогресс
  - `WARNING` - предупреждения (например, игнорирование значений для timestamp)
  - `ERROR` - ошибки перед выходом
- **FR-8.4:** Опционально: дублирование логов в файл

---

## 3. НЕФУНКЦИОНАЛЬНЫЕ ТРЕБОВАНИЯ (Non-Functional Requirements)

### NFR-1: Обработка ошибок
- **NFR-1.1:** Все ошибки должны обрабатываться gracefully без traceback
- **NFR-1.2:** Использование `sys.exit(1)` вместо `raise` для критических ошибок
- **NFR-1.3:** Каждая ошибка должна быть залогирована с `logging.error()`
- **NFR-1.4:** Валидация всех входных параметров

### NFR-2: Качество кода
- **NFR-2.1:** Код должен быть разделен на функции/классы/логические блоки
- **NFR-2.2:** Избегать монолитного кода
- **NFR-2.3:** Следование принципам чистого кода
- **NFR-2.4:** Понятные имена переменных и функций

### NFR-3: Тестирование
- **NFR-3.1:** Использование `pytest` для unit-тестов
- **NFR-3.2:** Покрытие всех основных функциональностей тестами
- **NFR-3.3:** Использование параметризованных тестов
- **NFR-3.4:** Использование fixtures для тестов с файлами

### NFR-4: Производительность
- **NFR-4.1:** Эффективная генерация больших объемов данных
- **NFR-4.2:** Параллельная обработка при использовании multiprocessing
- **NFR-4.3:** Оптимальное использование памяти

### NFR-5: Совместимость
- **NFR-5.1:** Python 3.6+
- **NFR-5.2:** Использование только стандартной библиотеки Python
- **NFR-5.3:** Кросс-платформенность (Windows, Linux, macOS)

---

## 4. ТЕХНИЧЕСКИЕ ТРЕБОВАНИЯ

### Обязательные модули Python:
1. `argparse` - парсинг аргументов командной строки
2. `json` - работа с JSON форматом
3. `os` / `shutil` - операции с файловой системой
4. `time` - генерация timestamp
5. `random` - генерация случайных данных
6. `configparser` - чтение конфигурации
7. `logging` - логирование
8. `uuid` - генерация UUID
9. `pytest` - тестирование
10. `multiprocessing` - параллельная обработка
11. `sys` - системные операции и выход

### Входные параметры утилиты:

| Параметр | Тип | Описание | Валидация |
|----------|-----|----------|-----------|
| `path_to_save_files` | str (позиционный) | Путь для сохранения файлов | Проверка существования, что это директория |
| `--files_count` | int | Количество файлов для генерации | >= 0 (0 = вывод в консоль) |
| `--file_name` | str | Базовое имя файла | Валидное имя файла |
| `--file_prefix` | choice | Префикс имени файла | ['count', 'random', 'uuid'] |
| `--data_schema` | str | JSON схема или путь к файлу | Валидный JSON |
| `--data_lines` | int | Количество строк в каждом файле | > 0 |
| `--clear_path` | flag | Очистка существующих файлов | store_true |
| `--multiprocessing` | int | Количество процессов | >= 1, <= os.cpu_count() |

---

## 5. АРХИТЕКТУРА СИСТЕМЫ

### 5.1. Общая архитектура

```
┌─────────────────────────────────────────────────────────┐
│                    CLI Interface                         │
│                   (argparse)                             │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│               Configuration Manager                      │
│            (ConfigParser + Defaults)                     │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                 Validator Module                         │
│          (Validate all input parameters)                 │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              Schema Parser Module                        │
│         (Parse and validate data schema)                 │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│            Data Generator Module                         │
│     (Generate data based on parsed schema)               │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│           File Manager Module                            │
│  (Handle file creation, naming, and cleanup)             │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│         Multiprocessing Coordinator                      │
│      (Distribute work across processes)                  │
└─────────────────────────────────────────────────────────┘
```

### 5.2. Модульная структура

#### Модуль 1: CLI Interface (`cli.py`)
**Ответственность:**
- Определение интерфейса командной строки
- Парсинг аргументов с помощью argparse
- Отображение help-сообщений
- Точка входа в программу

**Функции:**
- `create_parser()` - создание ArgumentParser
- `parse_arguments()` - парсинг аргументов
- `main()` - главная функция

#### Модуль 2: Configuration Manager (`config.py`)
**Ответственность:**
- Чтение default.ini
- Предоставление значений по умолчанию
- Мердж значений из конфига и CLI

**Функции:**
- `load_default_config()` - загрузка default.ini
- `get_config_value()` - получение значения параметра
- `create_default_config()` - создание default.ini если его нет

#### Модуль 3: Validator (`validator.py`)
**Ответственность:**
- Валидация всех входных параметров
- Проверка путей, диапазонов значений
- Валидация схемы данных

**Функции:**
- `validate_path()` - проверка path_to_save_files
- `validate_files_count()` - проверка files_count
- `validate_multiprocessing()` - проверка и коррекция multiprocessing
- `validate_schema()` - базовая проверка schema
- `validate_all_parameters()` - валидация всех параметров

#### Модуль 4: Schema Parser (`schema_parser.py`)
**Ответственность:**
- Парсинг JSON схемы
- Разбор type:value нотации
- Подготовка генераторов для каждого поля

**Классы/Функции:**
- `SchemaParser` класс
  - `parse()` - главный метод парсинга
  - `parse_field()` - парсинг отдельного поля
  - `parse_type_and_value()` - разбор type:value
  - `validate_field_type()` - проверка типа
  - `get_field_generators()` - получение генераторов

#### Модуль 5: Data Generator (`data_generator.py`)
**Ответственность:**
- Генерация данных согласно схеме
- Реализация различных стратегий генерации
- Генерация одной строки/множества строк

**Классы/Функции:**
- `DataGenerator` класс
  - `generate_line()` - генерация одной строки
  - `generate_lines()` - генерация множества строк
- Функции генерации для каждого типа:
  - `generate_timestamp()` - текущий timestamp
  - `generate_str_rand()` - случайный UUID
  - `generate_int_rand()` - случайное число
  - `generate_from_list()` - выбор из списка
  - `generate_int_range()` - число в диапазоне
  - `generate_static_value()` - статическое значение

#### Модуль 6: File Manager (`file_manager.py`)
**Ответственность:**
- Создание и именование файлов
- Запись данных в файлы (JSON Lines формат)
- Очистка директории
- Вывод в консоль

**Функции:**
- `generate_file_name()` - генерация имени файла с префиксом
- `write_jsonlines()` - запись данных в JSON Lines формат
- `clear_directory()` - удаление файлов с совпадающим именем
- `write_to_console()` - вывод данных в stdout
- `create_single_file()` - создание одного файла

#### Модуль 7: Multiprocessing Coordinator (`multiprocessor.py`)
**Ответственность:**
- Координация параллельной генерации
- Распределение работы между процессами
- Сбор результатов

**Функции:**
- `distribute_work()` - распределение количества файлов
- `generate_files_parallel()` - параллельная генерация
- `worker_function()` - функция для worker процесса

#### Модуль 8: Logger Setup (`logger.py`)
**Ответственность:**
- Настройка логирования
- Форматирование сообщений

**Функции:**
- `setup_logger()` - настройка logger
- `log_start()` - логирование начала работы
- `log_completion()` - логирование завершения

#### Модуль 9: Utils (`utils.py`)
**Ответственность:**
- Вспомогательные функции
- Общие утилиты

**Функции:**
- `is_json_file()` - проверка, является ли строка путем к файлу
- `load_json_from_file()` - загрузка JSON из файла
- `safe_exit()` - безопасный выход с логированием

---

## 6. СТРУКТУРА ПРОЕКТА

```
python_capstone_project_ndragancea/
│
├── dataforge/                      # Главный пакет утилиты
│   ├── __init__.py
│   ├── __main__.py                 # Точка входа (python -m dataforge)
│   ├── cli.py                      # CLI интерфейс
│   ├── config.py                   # Работа с конфигурацией
│   ├── validator.py                # Валидация параметров
│   ├── schema_parser.py            # Парсинг схемы данных
│   ├── data_generator.py           # Генерация данных
│   ├── file_manager.py             # Управление файлами
│   ├── multiprocessor.py           # Многопроцессорность
│   ├── logger.py                   # Настройка логирования
│   └── utils.py                    # Вспомогательные функции
│
├── tests/                          # Тесты
│   ├── __init__.py
│   ├── conftest.py                 # Fixtures для pytest
│   ├── test_schema_parser.py      # Тесты парсера схемы
│   ├── test_data_generator.py     # Тесты генератора данных
│   ├── test_validator.py          # Тесты валидатора
│   ├── test_file_manager.py       # Тесты файлового менеджера
│   ├── test_multiprocessing.py    # Тесты многопроцессорности
│   ├── test_integration.py        # Интеграционные тесты
│   └── fixtures/                  # Тестовые данные
│       ├── test_schema_1.json
│       ├── test_schema_2.json
│       └── ...
│
├── default.ini                     # Конфигурация по умолчанию
├── requirements.txt                # Зависимости (для pytest)
├── README.md                       # Документация проекта
├── setup.py                        # Setup script для установки
└── .gitignore                      # Git ignore file
```

---

## 7. ДЕТАЛЬНЫЙ ПЛАН РЕАЛИЗАЦИИ

### ЭТАП 1: Подготовка проекта (1-2 часа)
**Задачи:**
1. Создать структуру проекта (папки и файлы)
2. Создать `default.ini` с параметрами по умолчанию
3. Создать `requirements.txt`
4. Создать базовый `README.md`
5. Настроить `.gitignore`
6. Инициализировать Git репозиторий

**Результат:** Готовая структура проекта

---

### ЭТАП 2: Реализация базовых модулей (3-4 часа)

#### 2.1. Logger Setup (`logger.py`)
```python
# Функции:
- setup_logger() - базовая настройка
- Форматирование сообщений
```

#### 2.2. Configuration Manager (`config.py`)
```python
# Функции:
- load_default_config() - чтение default.ini
- create_default_config() - создание default.ini если отсутствует
```

#### 2.3. Utils (`utils.py`)
```python
# Функции:
- is_json_file() - определение, строка или путь к файлу
- load_json_from_file() - загрузка JSON
- safe_exit() - корректный выход с ошибкой
```

**Тестирование:**
- Написать базовые тесты для каждого модуля

**Результат:** Работающие вспомогательные модули

---

### ЭТАП 3: CLI Interface (2-3 часа)

#### 3.1. Реализация `cli.py`
```python
# Создание ArgumentParser с:
- Позиционный аргумент path_to_save_files
- Опциональные аргументы (--files_count, --file_name, и т.д.)
- Настройка help-сообщений
- Определение choices для file_prefix
- Настройка store_true для clear_path
```

#### 3.2. Создание точки входа
```python
# __main__.py
# Функция main()
```

**Тестирование:**
- Проверка парсинга аргументов
- Проверка help-сообщения

**Результат:** Работающий CLI интерфейс

---

### ЭТАП 4: Validator Module (2-3 часа)

#### 4.1. Реализация `validator.py`
```python
# Функции валидации:
- validate_path() - проверка существования и типа пути
- validate_files_count() - files_count >= 0
- validate_multiprocessing() - коррекция до os.cpu_count()
- validate_data_lines() - data_lines > 0
- validate_schema() - базовая проверка JSON
- validate_all_parameters() - комплексная валидация
```

**Тестирование:**
- Параметризованные тесты для каждой функции валидации
- Тесты на граничные случаи
- Тесты на ошибки

**Результат:** Полная валидация входных данных

---

### ЭТАП 5: Schema Parser (4-5 часов)

#### 5.1. Реализация `schema_parser.py`
```python
# Класс SchemaParser:
- parse() - основной метод
- parse_field() - парсинг одного поля
- _split_type_value() - разделение по ":"
- _validate_type() - проверка типа (timestamp/str/int)
- _parse_str_value() - парсинг значений для str
- _parse_int_value() - парсинг значений для int
- _parse_timestamp_value() - парсинг для timestamp (с warning)
- _parse_list() - парсинг списка значений
- _parse_range() - парсинг rand(from, to)

# Возвращает структуру:
{
  'field_name': {
    'type': 'str'|'int'|'timestamp',
    'strategy': 'rand'|'list'|'range'|'static'|'empty',
    'value': None | list | (from, to) | static_value
  }
}
```

**Тестирование:**
- Параметризованные тесты для разных типов и стратегий
- Тесты на некорректные схемы
- Тесты на граничные случаи

**Результат:** Полный парсер схемы данных

---

### ЭТАП 6: Data Generator (3-4 часа)

#### 6.1. Реализация `data_generator.py`
```python
# Класс DataGenerator:
- __init__(parsed_schema) - инициализация с parsed schema
- generate_line() - генерация одной строки данных
- generate_lines(count) - генерация множества строк
- _generate_field_value() - генерация значения для одного поля

# Вспомогательные функции:
- generate_timestamp() -> float
- generate_str_rand() -> str (UUID)
- generate_int_rand() -> int
- generate_from_list(values) -> any
- generate_int_range(from, to) -> int
- generate_static(value) -> value
- generate_empty(type) -> None | ""
```

**Тестирование:**
- Параметризованные тесты для разных типов данных
- Тесты для разных схем данных
- Проверка формата вывода

**Результат:** Рабочий генератор данных

---

### ЭТАП 7: File Manager (3-4 часа)

#### 7.1. Реализация `file_manager.py`
```python
# Функции:
- generate_file_name(base_name, prefix_type, index) -> str
- write_jsonlines(filepath, data_lines) -> None
- write_to_console(data_lines) -> None
- clear_directory(path, file_pattern) -> None
- create_single_file(params) -> str (filepath)
  # params: path, file_name, prefix, index, data
```

**Тестирование:**
- Тест на генерацию имен файлов с разными префиксами
- Тест на запись файлов (с использованием temporary files)
- Тест на очистку директории (clear_path)
- Тест с использованием fixtures

**Результат:** Полное управление файлами

---

### ЭТАП 8: Multiprocessing Coordinator (3-4 часа)

#### 8.1. Реализация `multiprocessor.py`
```python
# Функции:
- distribute_work(total_files, num_processes) -> list[int]
  # Возвращает список с количеством файлов для каждого процесса
- worker_function(args) -> list[str]
  # Функция для worker процесса
  # args: (process_id, files_to_create, common_params)
- generate_files_parallel(params) -> list[str]
  # Главная функция для параллельной генерации
```

**Тестирование:**
- Тест на распределение работы
- Тест на создание файлов с multiprocessing > 1
- Проверка количества созданных файлов
- Проверка корректности данных

**Результат:** Рабочая параллельная генерация

---

### ЭТАП 9: Интеграция и главный модуль (2-3 часа)

#### 9.1. Финальная интеграция в `cli.py`
```python
# main() функция:
1. Парсинг аргументов
2. Загрузка конфигурации
3. Валидация параметров
4. Парсинг схемы
5. Выбор режима (консоль или файлы)
6. Выбор режима (single-process или multi-process)
7. Генерация данных
8. Логирование результатов
```

**Тестирование:**
- Интеграционные тесты
- End-to-end тесты с различными параметрами

**Результат:** Полностью рабочая утилита

---

### ЭТАП 10: Дополнительные тесты (2-3 часа) ✅ ЗАВЕРШЕНО

#### 10.1. Написание всех обязательных тестов
1. ✅ Параметризованный тест для разных типов данных
2. ✅ Параметризованный тест для разных схем
3. ✅ Тест с временными файлами и fixtures для загрузки схемы из файла
4. ✅ Тест для clear_path
5. ✅ Тест для сохранения файлов на диск
6. ✅ Тест для проверки количества файлов при multiprocessing > 1
7. ✅ Собственный дополнительный тест

#### 10.2. Специальные тесты (test_special.py)
Создано 8 специальных тестов:
1. ✅ **test_performance_single_vs_parallel** - Сравнение производительности single vs multi
2. ✅ **test_data_consistency_across_runs** - Проверка консистентности данных
3. ✅ **test_complex_mixed_schema_generation** - Комплексная схема со всеми типами
4. ✅ **test_stress_large_files** - Стресс-тест с большими файлами
5. ✅ **test_edge_cases_single_line_single_file** - Граничный случай (1 файл, 1 строка)
6. ✅ **test_edge_cases_many_files_few_lines** - Граничный случай (50 файлов, 2 строки)
7. ✅ **test_unique_prefixes_verification** - Проверка уникальности префиксов
8. ✅ **test_data_distribution_randomness** - Статистическая проверка распределения

**Результат:** Полное тестовое покрытие - **295 тестов, все проходят успешно**

---

### ЭТАП 11: Документация и финальная проверка (1-2 часа) ✅ ЗАВЕРШЕНО

#### 11.1. Завершение документации
- ✅ Обновить README.md с примерами использования
  - Добавлены 8 практических примеров
  - Секция "Advanced Usage" с оптимизацией производительности
  - FAQ и Troubleshooting
  - Метрики производительности
  - Расширенная информация о тестировании
- ✅ Добавить docstrings ко всем функциям и классам
  - Все модули имеют полную документацию
- ✅ Создать примеры схем данных
  - Создана папка `examples/` с 6 готовыми схемами:
    1. user_activity_schema.json
    2. ecommerce_orders_schema.json
    3. iot_sensors_schema.json
    4. web_logs_schema.json
    5. financial_transactions_schema.json
    6. social_media_schema.json
  - Создан examples/README.md с подробным описанием

#### 11.2. Финальная проверка
- ✅ Запуск всех тестов - **295 passed in 3.79s**
- ✅ Проверка всех требований - все требования выполнены
- ✅ Проверка обработки ошибок - все ошибки обрабатываются корректно
- ✅ Тестирование на macOS - успешно

**Результат:** Готовый к сдаче проект с полной документацией и примерами

---

## 8. ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ

### Пример 1: Генерация в текущую директорию
```bash
python -m dataforge . --files_count=3 --file_name=test_data --file_prefix=count \
  --data_schema='{"date":"timestamp:", "name":"str:rand", "age":"int:rand(18,65)"}'
```

**Результат:**
- test_data_1.json
- test_data_2.json
- test_data_3.json

### Пример 2: Загрузка схемы из файла
```bash
python -m dataforge ./output --files_count=5 --data_schema=./schemas/user_schema.json
```

### Пример 3: Вывод в консоль
```bash
python -m dataforge . --files_count=0 --data_lines=10 \
  --data_schema='{"id":"int:rand", "status":"str:[\"active\",\"inactive\"]"}'
```

### Пример 4: С многопроцессорностью
```bash
python -m dataforge ./data --files_count=100 --multiprocessing=4 \
  --file_prefix=uuid --clear_path
```

---

## 9. СТРУКТУРА default.ini

```ini
[DEFAULT]
files_count = 10
file_name = generated_data
file_prefix = count
data_lines = 1000
multiprocessing = 1

[SCHEMA]
# Пример схемы по умолчанию
default_schema = {"id": "int:rand", "timestamp": "timestamp:", "value": "str:rand"}
```

---

## 10. КРИТЕРИИ ПРИЕМКИ (Acceptance Criteria)

### ✅ Функциональность
- [ ] Все функции реализованы и работают
- [ ] Все параметры командной строки работают корректно
- [ ] Генерация данных соответствует схеме
- [ ] Multiprocessing работает корректно
- [ ] Префиксы файлов работают (count, random, uuid)
- [ ] clear_path корректно удаляет файлы
- [ ] Вывод в консоль работает (files_count=0)

### ✅ Обработка ошибок
- [ ] Все возможные ошибки обработаны
- [ ] Нет необработанных traceback
- [ ] Используется sys.exit(1) вместо raise
- [ ] Все ошибки логируются с logging.error()
- [ ] Корректная валидация всех входных параметров

### ✅ Качество кода
- [ ] Код разделен на функции/классы/модули
- [ ] Нет монолитного кода
- [ ] Понятные имена переменных и функций
- [ ] Docstrings для всех публичных функций

### ✅ Тестирование
- [ ] Все unit-тесты написаны
- [ ] Параметризованные тесты для типов данных
- [ ] Параметризованные тесты для схем
- [ ] Тесты с fixtures и временными файлами
- [ ] Тест для clear_path
- [ ] Тест для multiprocessing
- [ ] Все тесты проходят успешно

### ✅ Документация
- [ ] README.md с инструкциями
- [ ] Примеры использования
- [ ] Help-сообщения информативны
- [ ] default.ini создан и заполнен

---

## 11. ТЕСТОВЫЕ СЦЕНАРИИ

### Тест 1: Разные типы данных (параметризованный)
```python
@pytest.mark.parametrize("data_type,strategy,expected_type", [
    ("str", "rand", str),
    ("int", "rand", int),
    ("timestamp", "", float),
    ("str", "['val1','val2']", str),
    ("int", "rand(1,100)", int),
])
def test_data_types(data_type, strategy, expected_type):
    # Тест генерации разных типов
```

### Тест 2: Разные схемы (параметризованный)
```python
@pytest.mark.parametrize("schema", [
    {"name": "str:rand"},
    {"age": "int:rand(1,90)"},
    {"date": "timestamp:", "name": "str:rand"},
    {"status": "str:['active','inactive','pending']"},
])
def test_schemas(schema):
    # Тест разных схем
```

### Тест 3: Загрузка схемы из файла (с fixtures)
```python
@pytest.fixture
def temp_schema_file(tmp_path):
    schema = {"test": "str:rand"}
    file_path = tmp_path / "schema.json"
    with open(file_path, 'w') as f:
        json.dump(schema, f)
    return file_path

def test_schema_from_file(temp_schema_file):
    # Тест загрузки из файла
```

### Тест 4: clear_path
```python
def test_clear_path(tmp_path):
    # Создать файлы
    # Запустить с clear_path
    # Проверить что старые удалены
```

### Тест 5: Сохранение на диск
```python
def test_save_to_disk(tmp_path):
    # Генерация файлов
    # Проверка существования
    # Проверка содержимого (JSON Lines)
```

### Тест 6: Multiprocessing
```python
def test_multiprocessing(tmp_path):
    # Генерация с multiprocessing=4
    # Проверка количества файлов
    # Проверка что все файлы валидны
```

### Тест 7: Собственный тест
```python
def test_custom():
    # Например, тест на производительность
    # или тест на очень большие данные
    # или тест на edge cases
```

---

## 12. ПОТЕНЦИАЛЬНЫЕ ПРОБЛЕМЫ И РЕШЕНИЯ

### Проблема 1: Конфликт имен файлов при multiprocessing
**Решение:** Использовать уникальные префиксы или счетчики для каждого процесса

### Проблема 2: Обработка специальных символов в схеме
**Решение:** Экранирование или использование raw strings

### Проблема 3: Производительность при больших объемах
**Решение:** Генерация и запись данных порциями, buffering

### Проблема 4: Кросс-платформенность путей
**Решение:** Использование os.path или pathlib

### Проблема 5: Обработка прерывания (Ctrl+C)
**Решение:** Signal handlers для graceful shutdown

---

## 13. РАСШИРЕНИЯ (OPTIONAL)

Если останется время, можно добавить:

1. **Дополнительные типы данных:**
   - float
   - bool
   - date (formatted dates)

2. **Дополнительные форматы вывода:**
   - CSV
   - XML
   - Parquet

3. **Прогресс-бар:** Показ прогресса генерации

4. **Валидация сгенерированных данных:** Проверка соответствия схеме

5. **Статистика:** Вывод статистики о сгенерированных данных

6. **Шаблоны схем:** Предустановленные схемы для типичных сценариев

---

## 14. TIMELINE ОЦЕНКА

**Общее время: 25-35 часов**

- Этап 1: Подготовка - 1-2 часа
- Этап 2: Базовые модули - 3-4 часа
- Этап 3: CLI - 2-3 часа
- Этап 4: Validator - 2-3 часа
- Этап 5: Schema Parser - 4-5 часов
- Этап 6: Data Generator - 3-4 часа
- Этап 7: File Manager - 3-4 часа
- Этап 8: Multiprocessing - 3-4 часа
- Этап 9: Интеграция - 2-3 часа
- Этап 10: Тесты - 2-3 часа
- Этап 11: Документация - 1-2 часа

---

## 15. CHECKLIST ДЛЯ ПРОВЕРКИ

### Перед началом кодирования:
- [ ] Изучены все обязательные модули Python
- [ ] Понятны все требования
- [ ] Создана структура проекта

### Во время разработки:
- [ ] Каждый модуль тестируется отдельно
- [ ] Логирование добавлено везде где нужно
- [ ] Обработка ошибок реализована
- [ ] Код читаемый и структурированный

### Перед сдачей:
- [ ] Все тесты проходят
- [ ] Все требования выполнены
- [ ] Документация полная
- [ ] Примеры работают
- [ ] Нет необработанных исключений
- [ ] Help-сообщения информативны
- [ ] default.ini создан
- [ ] README.md актуален

---

**Конец документа**

